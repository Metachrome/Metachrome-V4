<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Balance Synchronization Test - METACHROME V2</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a1a;
            color: #fff;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .panel {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #444;
        }
        .test-section {
            margin-bottom: 20px;
            padding: 15px;
            background: #333;
            border-radius: 5px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        button.danger {
            background: #dc3545;
        }
        button.danger:hover {
            background: #c82333;
        }
        button.success {
            background: #28a745;
        }
        button.success:hover {
            background: #218838;
        }
        input, select {
            padding: 8px;
            margin: 5px;
            border: 1px solid #555;
            border-radius: 4px;
            background: #444;
            color: #fff;
        }
        .balance-display {
            font-size: 24px;
            font-weight: bold;
            color: #28a745;
            margin: 10px 0;
        }
        .log {
            background: #000;
            color: #0f0;
            padding: 10px;
            border-radius: 4px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        h1, h2, h3 {
            color: #fff;
        }
    </style>
</head>
<body>
    <h1>üîÑ Balance Synchronization Test - METACHROME V2</h1>
    
    <div class="status" id="connectionStatus">
        <strong>WebSocket:</strong> <span id="wsStatus">Connecting...</span>
    </div>

    <div class="container">
        <!-- Left Panel: Balance Display & Controls -->
        <div class="panel">
            <h2>üí∞ Balance Monitor</h2>
            
            <div class="test-section">
                <h3>Current Balance</h3>
                <div class="balance-display" id="currentBalance">Loading...</div>
                <p>User: <span id="currentUser">Loading...</span></p>
                <button onclick="refreshBalance()">üîÑ Refresh Balance</button>
            </div>

            <div class="test-section">
                <h3>üè¶ Superadmin Operations</h3>
                <div>
                    <input type="number" id="depositAmount" placeholder="Amount" value="1000">
                    <button class="success" onclick="testDeposit()">üí∞ Deposit</button>
                    <button class="danger" onclick="testWithdrawal()">üí∏ Withdraw</button>
                </div>
                <div>
                    <input type="text" id="depositNote" placeholder="Note (optional)" value="Test operation">
                </div>
            </div>

            <div class="test-section">
                <h3>üìä Trading Operations</h3>
                <div>
                    <select id="tradeSymbol">
                        <option value="BTCUSDT">BTC/USDT</option>
                        <option value="ETHUSDT">ETH/USDT</option>
                    </select>
                    <select id="tradeDirection">
                        <option value="up">UP</option>
                        <option value="down">DOWN</option>
                    </select>
                </div>
                <div>
                    <input type="number" id="tradeAmount" placeholder="Trade Amount" value="100">
                    <select id="tradeDuration">
                        <option value="30">30s</option>
                        <option value="60">60s</option>
                    </select>
                </div>
                <div>
                    <button onclick="testOptionsTrade()">üéØ Options Trade</button>
                    <button onclick="testSpotBuy()">üìà Spot Buy</button>
                    <button onclick="testSpotSell()">üìâ Spot Sell</button>
                </div>
            </div>

            <div class="test-section">
                <h3>üéÆ Trading Controls</h3>
                <div>
                    <button onclick="setTradingMode('normal')">‚ö™ Normal</button>
                    <button class="success" onclick="setTradingMode('win')">‚úÖ Force Win</button>
                    <button class="danger" onclick="setTradingMode('lose')">‚ùå Force Lose</button>
                </div>
                <p>Current Mode: <span id="tradingMode">normal</span></p>
            </div>
        </div>

        <!-- Right Panel: Real-time Log -->
        <div class="panel">
            <h2>üì° Real-time Updates Log</h2>
            <div class="log" id="logContainer"></div>
            <button onclick="clearLog()">üóëÔ∏è Clear Log</button>
            <button onclick="testAllOperations()">üß™ Test All Operations</button>
        </div>
    </div>

    <script>
        let ws = null;
        let currentUserId = 'user-1'; // Default user for testing
        let currentBalance = 0;
        let isConnected = false;

        // Initialize WebSocket connection
        function initWebSocket() {
            try {
                ws = new WebSocket('ws://127.0.0.1:3000/ws');
                
                ws.onopen = function() {
                    isConnected = true;
                    updateConnectionStatus(true);
                    log('‚úÖ WebSocket connected successfully');
                    
                    // Subscribe to balance updates
                    ws.send(JSON.stringify({
                        type: 'subscribe_user_balance',
                        userId: currentUserId
                    }));
                };

                ws.onmessage = function(event) {
                    const message = JSON.parse(event.data);
                    handleWebSocketMessage(message);
                };

                ws.onclose = function() {
                    isConnected = false;
                    updateConnectionStatus(false);
                    log('‚ùå WebSocket disconnected');
                    
                    // Attempt to reconnect after 3 seconds
                    setTimeout(initWebSocket, 3000);
                };

                ws.onerror = function(error) {
                    log('‚ùå WebSocket error: ' + error);
                };
            } catch (error) {
                log('‚ùå Failed to connect WebSocket: ' + error);
                setTimeout(initWebSocket, 3000);
            }
        }

        function handleWebSocketMessage(message) {
            log(`üì® Received: ${message.type}`);
            
            switch (message.type) {
                case 'balance_update':
                    if (message.data.userId === currentUserId) {
                        updateBalance(message.data.newBalance);
                        log(`üí∞ Balance updated: ${message.data.newBalance} USDT (${message.data.changeType})`);
                    }
                    break;
                    
                case 'user_balance_init':
                    if (message.data.userId === currentUserId) {
                        updateBalance(message.data.balance);
                        updateTradingMode(message.data.tradingMode);
                        log(`üîÑ Balance initialized: ${message.data.balance} USDT`);
                    }
                    break;
                    
                case 'trading_control_update':
                    if (message.data.userId === currentUserId) {
                        updateTradingMode(message.data.newMode);
                        log(`üéØ Trading mode changed: ${message.data.oldMode} ‚Üí ${message.data.newMode}`);
                    }
                    break;
                    
                default:
                    log(`üìã Other message: ${JSON.stringify(message)}`);
            }
        }

        function updateConnectionStatus(connected) {
            const statusEl = document.getElementById('connectionStatus');
            const wsStatusEl = document.getElementById('wsStatus');
            
            if (connected) {
                statusEl.className = 'status connected';
                wsStatusEl.textContent = 'Connected ‚úÖ';
            } else {
                statusEl.className = 'status disconnected';
                wsStatusEl.textContent = 'Disconnected ‚ùå';
            }
        }

        function updateBalance(balance) {
            currentBalance = balance;
            document.getElementById('currentBalance').textContent = `${balance} USDT`;
        }

        function updateTradingMode(mode) {
            document.getElementById('tradingMode').textContent = mode;
        }

        function log(message) {
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            logContainer.innerHTML += `[${timestamp}] ${message}\n`;
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function clearLog() {
            document.getElementById('logContainer').innerHTML = '';
        }

        // API request helper
        async function apiRequest(method, url, data = null) {
            const options = {
                method: method,
                headers: {
                    'Content-Type': 'application/json',
                },
                mode: 'cors', // Enable CORS
                credentials: 'same-origin' // Include credentials for same origin
            };

            if (data) {
                options.body = JSON.stringify(data);
            }

            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response;
            } catch (error) {
                console.error('API Request failed:', error);
                throw error;
            }
        }

        // Test functions
        async function refreshBalance() {
            try {
                log('üîÑ Refreshing balance...');
                const response = await apiRequest('GET', `/api/user/balances?userId=${currentUserId}`);
                const data = await response.json();
                
                if (data && data.length > 0) {
                    const usdtBalance = data.find(b => b.currency === 'USDT');
                    if (usdtBalance) {
                        updateBalance(usdtBalance.balance);
                        log(`‚úÖ Balance refreshed: ${usdtBalance.balance} USDT`);
                    }
                }
            } catch (error) {
                log(`‚ùå Failed to refresh balance: ${error}`);
            }
        }

        async function testDeposit() {
            const amount = document.getElementById('depositAmount').value;
            const note = document.getElementById('depositNote').value;
            
            try {
                log(`üí∞ Testing deposit: ${amount} USDT`);
                const response = await apiRequest('POST', '/api/superadmin/deposit', {
                    userId: currentUserId,
                    amount: parseFloat(amount),
                    note: note
                });
                
                const result = await response.json();
                if (result.success) {
                    log(`‚úÖ Deposit successful: ${amount} USDT`);
                } else {
                    log(`‚ùå Deposit failed: ${result.message}`);
                }
            } catch (error) {
                log(`‚ùå Deposit error: ${error}`);
            }
        }

        async function testWithdrawal() {
            const amount = document.getElementById('depositAmount').value;
            const note = document.getElementById('depositNote').value;
            
            try {
                log(`üí∏ Testing withdrawal: ${amount} USDT`);
                const response = await apiRequest('POST', '/api/superadmin/withdrawal', {
                    userId: currentUserId,
                    amount: parseFloat(amount),
                    note: note
                });
                
                const result = await response.json();
                if (result.success) {
                    log(`‚úÖ Withdrawal successful: ${amount} USDT`);
                } else {
                    log(`‚ùå Withdrawal failed: ${result.message}`);
                }
            } catch (error) {
                log(`‚ùå Withdrawal error: ${error}`);
            }
        }

        async function testOptionsTrade() {
            const symbol = document.getElementById('tradeSymbol').value;
            const direction = document.getElementById('tradeDirection').value;
            const amount = document.getElementById('tradeAmount').value;
            const duration = document.getElementById('tradeDuration').value;

            try {
                log(`üéØ Testing options trade: ${amount} USDT on ${symbol} ${direction} ${duration}s`);
                const response = await apiRequest('POST', '/api/trades', {
                    userId: currentUserId,
                    symbol: symbol,
                    direction: direction,
                    amount: parseFloat(amount),
                    duration: parseInt(duration)
                });

                const result = await response.json();
                if (result.success) {
                    log(`‚úÖ Options trade created: ${result.trade.id}`);
                } else {
                    log(`‚ùå Options trade failed: ${result.message}`);
                }
            } catch (error) {
                log(`‚ùå Options trade error: ${error}`);
            }
        }

        async function testSpotBuy() {
            const symbol = document.getElementById('tradeSymbol').value;
            const amount = document.getElementById('tradeAmount').value;

            try {
                log(`üìà Testing spot buy: ${amount} USDT of ${symbol}`);
                const response = await apiRequest('POST', '/api/spot/orders', {
                    userId: currentUserId,
                    symbol: symbol,
                    side: 'buy',
                    amount: parseFloat(amount),
                    type: 'market'
                });

                const result = await response.json();
                if (result.success) {
                    log(`‚úÖ Spot buy successful: ${result.order.id}`);
                } else {
                    log(`‚ùå Spot buy failed: ${result.message}`);
                }
            } catch (error) {
                log(`‚ùå Spot buy error: ${error}`);
            }
        }

        async function testSpotSell() {
            const symbol = document.getElementById('tradeSymbol').value;
            const amount = document.getElementById('tradeAmount').value;

            try {
                log(`üìâ Testing spot sell: ${amount} USDT of ${symbol}`);
                const response = await apiRequest('POST', '/api/spot/orders', {
                    userId: currentUserId,
                    symbol: symbol,
                    side: 'sell',
                    amount: parseFloat(amount),
                    type: 'market'
                });

                const result = await response.json();
                if (result.success) {
                    log(`‚úÖ Spot sell successful: ${result.order.id}`);
                } else {
                    log(`‚ùå Spot sell failed: ${result.message}`);
                }
            } catch (error) {
                log(`‚ùå Spot sell error: ${error}`);
            }
        }

        async function setTradingMode(mode) {
            try {
                log(`üéÆ Setting trading mode to: ${mode}`);
                const response = await apiRequest('POST', '/api/admin/trading-controls', {
                    userId: currentUserId,
                    controlType: mode
                });

                const result = await response.json();
                if (result.success) {
                    log(`‚úÖ Trading mode set to: ${mode}`);
                    updateTradingMode(mode);
                } else {
                    log(`‚ùå Failed to set trading mode: ${result.message}`);
                }
            } catch (error) {
                log(`‚ùå Trading mode error: ${error}`);
            }
        }

        async function testAllOperations() {
            log('üß™ Starting comprehensive balance sync test...');

            // Test 1: Deposit
            await new Promise(resolve => setTimeout(resolve, 1000));
            await testDeposit();

            // Test 2: Options trade
            await new Promise(resolve => setTimeout(resolve, 2000));
            await testOptionsTrade();

            // Test 3: Spot buy
            await new Promise(resolve => setTimeout(resolve, 2000));
            await testSpotBuy();

            // Test 4: Spot sell
            await new Promise(resolve => setTimeout(resolve, 2000));
            await testSpotSell();

            // Test 5: Withdrawal
            await new Promise(resolve => setTimeout(resolve, 2000));
            await testWithdrawal();

            log('üèÅ Comprehensive test completed!');
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            log('üöÄ Balance Synchronization Test Started');
            document.getElementById('currentUser').textContent = currentUserId;
            initWebSocket();
            refreshBalance();
        });
    </script>
</body>
</html>
